input {
  beats {
    port => 5044
    codec => "plain"   # ğŸ‘ˆ å…ˆæŒ‰çº¯æ–‡æœ¬è¯»ï¼Œä¸å¼ºè¡Œè§£æ
  }
}


filter {
     # ğŸ‘‡ åœ¨æ‰€æœ‰å¤„ç†å‰æ‰“å°å®Œæ•´äº‹ä»¶ç»“æ„
     ruby {
       code => "
         puts '[DEBUG] === BEFORE FILTER ==='
         # puts JSON.pretty_generate(event.to_hash)
         puts event.to_hash.inspect
         puts '[DEBUG] ====================='
       "
     }

  # âœ… åªå¤„ç† order-service çš„æ—¥å¿—
  if [container][labels][com_docker_compose_service] == "order-service" {

    # âœ… ä½¿ç”¨ grok è§£æ Spring Boot æ ‡å‡†æ—¥å¿—æ ¼å¼
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:app.timestamp}  %{LOGLEVEL:app.level} %{NUMBER:app.pid} --- \[%{DATA:app.application}\] \[%{DATA:app.thread}\] \[%{DATA:app.traceId}\] %{JAVACLASS:app.class} *: %{GREEDYDATA:app.message}"
      }
      overwrite => ["message"]  # æŠŠè§£æåçš„å†…å®¹è¦†ç›–åŸ message
      tag_on_failure => ["grok-failure"]
    }

    # âœ… å¦‚æœè§£ææˆåŠŸï¼Œæ‰“æ ‡ç­¾å¹¶æ¸…ç†æ— ç”¨å­—æ®µ
    if "grok-failure" not in [tags] {
      mutate {
        add_tag => ["parsed-success"]
        remove_field => [
          "agent",
          "input",
          "host",
          "ecs",
          "log",
          "stream",
          "container"
          # ä¸æ”¯æŒç‚¹åˆ†è·¯å¾„åˆ é™¤
          #"container.id",
          #"container.image.name",
          #"container.labels.filebeat_enable"
        ]
      }
    } else {
      mutate {
        add_tag => ["parsed-failed"]
      }
    }

    # âœ… å¯é€‰ï¼šæŠŠ timestamp è½¬æˆ @timestampï¼ˆLogstash é»˜è®¤ç”¨æ¥æ”¶æ—¶é—´ï¼‰
    date {
      match => [ "app.timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }
}


output {
  stdout { codec => rubydebug }

  if "parsed-success" in [tags] {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "app-logs-%{+YYYY.MM.dd}"
      document_type => "_doc"
      template_overwrite => true
    }
  }

}